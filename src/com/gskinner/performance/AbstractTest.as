/*** AbstractTest by Grant Skinner. Feb 1, 2010* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2010 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.performance {		import flash.events.EventDispatcher;	import flash.events.Event;	import flash.utils.getQualifiedClassName;		/**	* Dispatched when the test completes. This is either when all iterations have been run, or when an error	* occurs.	* @eventType flash.events.Event	**/	[Event(name="complete", type="flash.events.Event")]		/**	* AbstractTest is a base class for building concrete test classes on. It should not be	* instantiated directly. It is possible to create new categories of tests by extending	* AbstractTest, but MethodTest and RenderTest should handle almost all requirements.	**/	public class AbstractTest extends EventDispatcher {			// public properties:		/**		* Optional name for this test. This is used for display purposes,		* and could also be used to uniquely identify the test for analytics systems.		**/		public var name:String;				/** Optional description for this test. **/		public var description:String;				/**		* The number of iterations to run with this test. Each iteration is run and timed independently.		* A larger number of iterations provides a larger sample, and more accurate results. Each iteration		* should run long enough to yield a significant result (ex. >10ms).		* <br/><br/>		* Setting this to 0 indicates that PerformanceTest should use the default iterations. When the test		* is run, this will be set to the iterations value of the TestSuite, or to 1.		**/		public var iterations:uint;				/** The average time for all iterations, or -1 if the test has not yet run successfully. **/		public var time:Number=-1;				/** The highest time for all iterations, or -1 if the test has not yet run successfully. **/		public var max:int=-1;				/** The lowest time for all iterations, or -1 if the test has not yet run successfully. **/		public var min:int=-1;				/**		* Provides a rough indication of how much the results of different iterations varied from the norm as a fraction of the average time.		* This is not standard deviation. This is calculated as (max-min)/time. It will always be 0 if only one iteration		* is run.		**/		public var deviation:Number=0;				/**		* An array of int values indicating the times for each iteration that was run.		**/		public var timeLog:Array;				/**		* If an error occurs in any iteration of the test, the error property will contain the resulting Error object.		* If no error occurs, it will be null.		**/		public var error:Error;				/**		* Specifies how many times to repeat the test within a single iteration. This allows you to increase the significance of your		* results, but also introduces some overhead time related to calling the method multiple times. It can be handy for comparative		* testing though.		**/		public var loops:uint;			// constructor:		/**		* AbstractTest should not be instantiated directly.		**/		public function AbstractTest(name:String=null, iterations:uint=0, loops:uint=1, description:String=null) {			this.name = name;			this.iterations = iterations;			this.loops = loops;			this.description = description;			timeLog = [];		}			// public methods:		/**		* PerformanceTest calls <code>run()</code> on tests to run and time them. The run() method returns the		* time for that iteration, or -1 if an error occurred. You would not generally call the run()		* method directly.		**/		public function run():int {			logError(new Error("AbstractTest cannot be run."));			return -1;		}				/**		* PerformanceTest calls <code>complete()</code> when all of the iterations of the test have been run. This causes		* the test to dispatch the COMPLETE event. You would not generally call this method directly.		**/		public function complete():void {			dispatchEvent(new Event(Event.COMPLETE));		}				/**		* Returns a string representation of this Test. Very handy for tracing:<br/>		* <code>trace(myTest);</code>		**/		override public function toString():String {			var className:String = getQualifiedClassName(this).split("::").pop();			return "["+className+(name?" name='"+name+"'":"")+(error?" error="+error.errorID:"")+" time="+time.toFixed(1)+" min="+min+" max="+max+" deviation="+deviation.toFixed(3)+"]";		}				/**		* Returns XML containing all of the information about this test.		* This is very useful for building analysis tools, and for saving out results to compare them in the future.		* <br/><br/>		* I might document the format some day, but for now it's simple enough to just trace the output of this function		* to see it.		**/		public function toXML():XML {			var className:String = getQualifiedClassName(this).split("::").pop();			var xml:XML = <{className} name="" time={time.toFixed(1)} min={min} max={max} deviation={deviation.toFixed(3)}/>;			if (name) { xml.@name=name; }			if (description) { xml.@description = description; }			if (error) {				xml.* += <error id={error.errorID} name={error.name} message={error.message}/>			}			var l:uint = timeLog.length;			for (var i:uint=0; i<l; i++) {				xml.* += <iteration time={timeLog[i]}/>			}			return xml;		}			// protected methods:		/** @private **/		protected function logIteration(time:int):void {			timeLog.push(time);			if (min == -1 || time < min) { min = time; }			if (time > max) { max = time; }			var l:uint = timeLog.length;			this.time = this.time*(l-1)/l+time/l; // running average.			deviation = time==0?0:(max-min)/this.time;  // not standard deviation, just an indicator of how consistent the results were.		}				/** @private **/		protected function logError(error:Error):void {			this.error = error;			min = max = time = -1;		}			}	}