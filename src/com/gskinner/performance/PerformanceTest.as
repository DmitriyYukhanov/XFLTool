/*** PerformanceTest by Grant Skinner. Feb 1, 2010* Visit www.gskinner.com/blog for documentation, updates and more free code.*** Copyright (c) 2010 Grant Skinner* * Permission is hereby granted, free of charge, to any person* obtaining a copy of this software and associated documentation* files (the "Software"), to deal in the Software without* restriction, including without limitation the rights to use,* copy, modify, merge, publish, distribute, sublicense, and/or sell* copies of the Software, and to permit persons to whom the* Software is furnished to do so, subject to the following* conditions:* * The above copyright notice and this permission notice shall be* included in all copies or substantial portions of the Software.* * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,* EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND* NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT* HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,* WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING* FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR* OTHER DEALINGS IN THE SOFTWARE.**/package com.gskinner.performance {		import flash.events.EventDispatcher;	import flash.utils.getTimer;	import flash.utils.Timer;	import flash.events.TimerEvent;	import flash.events.Event;	import flash.net.LocalConnection;	import flash.display.DisplayObject;			/**	* Dispatched when a test completes. You can use currentTest and currentTestSuite to gain access to	* the Test that just completed and the suite it belonged to.	* @eventType flash.events.Event	**/	[Event(name="complete", type="flash.events.Event")]		/**	* Dispatched when the last test in the queue completes, and the queue is empty.	* @eventType flash.events.Event	**/	[Event(name="close", type="flash.events.Event")]		/**	* <b>PerformanceTest ©2009 Grant Skinner, gskinner.com. Visit www.gskinner.com/libraries/performancetest/ for documentation, updates and more free code. Licensed under the MIT license - see the source file header for more information.</b>	* <hr/>	* PerformanceTest offers tools to benchmark different aspects of your code and graphics performance (see RenderTest).	* It allows very formal approaches to testing, with the creation of typed test objects (subclasses of AbstractTest), and organized	* test suites (instances of TestSuite). It also allows very simple, informal testing by passing in a function or a collection	* of functions.	* <br/><br/>	* At its simplest, you can test a function's execution time using the shortcut ptest method like so:<br/>	* <code>trace(ptest(myFunction));</code><br/>	* This will trace something similar to: [Test time=299.5 min=297 max=302 deviation=0.017]	* <br/><br/>	* Tests can be run immediately, or queued. Queuing prevents player time-outs for intense tests and also allows	* for cool-down time in between tests.	* <br/><br/>	* Tests can be run for multiple iterations, and the tests will return a min, max, and average run time. They also provide a	* deviation value that provides a rough indicator of how much the iterations' times varied as a fraction of the average time.	* <br/><br/>	* PerformanceTest will automatically force the GC to run before each test iteration to reduce its impact on the results.	**/	public class PerformanceTest extends EventDispatcher {			// static interface:		/** @private **/		protected static var _instance:PerformanceTest;				/**		* Returns a global instance of PerformanceTest. You can also create instances with <code>new PerformanceTest()</code>, but this		* makes it easier to maintain a single global queue of tests.		**/		public static function getInstance():PerformanceTest {			return _instance ? _instance : _instance = new PerformanceTest();		}				/**		* Forces the garbage collector to run. This is used internally to reduce the impact of GC operations on tests,		* and to measure memory usage.		**/		public static function runGC():void {			try {				new LocalConnection().connect("_FORCE_GC_");				new LocalConnection().connect("_FORCE_GC_");			} catch(e:*) {}		}				/**		* Shortcut method to add a new test or test suite to the global queue. The o param will accept an		* AbstractTest or TestSuite instance, a DisplayObject, a function / method, or an object. A DisplayObject		* will be converted to a RenderTest. A function will be converted to		* an instance of MethodTest, whereas an object will be converted to an instance of TestSuite using		* <code>TestSuite.fromObject()</code>. Returns the AbstractTest or Testsuite that was added.		* <br/><br/>		* The other parameters define properties of the test (see Test or TestSuite for details).		* If o is an AbstractTest or TestSuite instance, these parameters will override the existing properties if specified.		* <br/><br/>		* The <code>params</code> parameter only applies to function and MethodTest targets.		**/		public static function queue(o:Object, name:String=null, iterations:uint=0, loops:uint=0, params:Array=null):Object {			o = getTestable(o,name,iterations,loops,params);			if (o is AbstractTest) { getInstance().queueTest(o as AbstractTest); }			else { getInstance().queueTestSuite(o as TestSuite); }			return o;		}				/**		* Shortcut method that immediately runs a new test or test suite on the global PerformanceTest instance. See		* <code>queue</code> for more details.		**/		public static function run(o:Object, name:String=null, iterations:uint=0, loops:uint=0, params:Array=null):Object {			o = getTestable(o,name,iterations,loops,params);			if (o is AbstractTest) { getInstance().runTest(o as AbstractTest); }			else { getInstance().runTestSuite(o as TestSuite); }			return o;		}				/** @private **/		protected static function getTestable(o:Object, name:String, iterations:uint, loops:uint, params:Array):Object {			if (o is AbstractTest || o is TestSuite) {				if (name) { o.name = name; }				if (iterations != 0) { o.iterations = iterations; }				if (o is AbstractTest && loops>0) { o.loops = loops; }				if (o is MethodTest && params != null) { o.params = params; }				return o;			}			if (o is DisplayObject) { return new RenderTest(o as DisplayObject,null,name,iterations,loops); }			if (o is Function) { return new MethodTest(o as Function,params,name,iterations,loops); }			return TestSuite.fromObject(o,name,iterations,loops);		}			// protected properties:		/** @private **/		protected var queue:Array;		/** @private **/		protected var index:int;		/** @private **/		protected var iteration:int;		/** @private **/		protected var _currentTestSuite:TestSuite;		/** @private **/		protected var _currentTest:AbstractTest;		/** @private **/		protected var savedState:Object;		/** @private **/		protected var timer:Timer;		/** @private **/		protected var synchronous:Boolean;		/** @private **/		protected var _paused:Boolean;			// constructor:		public function PerformanceTest() {			queue = [];			timer = new Timer(50,1);			timer.addEventListener(TimerEvent.TIMER,handleTimer);		}			// getter / setters:		/**		* Sets the delay between test iterations. When running a series of high intensity tests,		* you may want to increase this value to provide additional cool-down time		* between tests.		**/		public function get delay():uint {			return timer.delay;		}		public function set delay(value:uint):void {			timer.delay = value;		}				/**		* Pauses or resumes the queue.		**/		public function get paused():Boolean {			return _paused;		}		public function set paused(value:Boolean):void {			if (_paused == value) { return; }			_paused = value;			if (queue.length > 0) {				timer.reset();				timer.start();			}		}				/**		* Returns the test that is currently running. This is mostly provided for use in conjunction		* with the COMPLETE event.		**/		public function get currentTest():AbstractTest {			return _currentTest;		}				/**		* Returns the test suite that is currently running, or null if none (if the current test does		* not belong to a suite, for example). This is mostly provided for use in conjunction with the 		* COMPLETE event.		**/		public function get currentTestSuite():TestSuite {			return _currentTestSuite;		}			// public methods:		/**		* Adds a TestSuite to the queue for this PerformanceTest instance.		* Returns the TestSuite that was passed in.		**/		public function queueTestSuite(testSuite:TestSuite):TestSuite {			return addToQueue(testSuite) as TestSuite;		}				/**		* Immediately runs the specified TestSuite.		* Returns the TestSuite that was passed in. This is handy for immediately		* accessing the results of the test, like so:<br/>		* <code>trace(runTestSuite(myTestSuite));</code>		**/		public function runTestSuite(testSuite:TestSuite):TestSuite {			return runSynchronous(testSuite) as TestSuite;		}				/**		* Adds a test to the queue for this PerformanceTest instance.		* The test can be any subclass of AbstractTest (ex. Test, RenderTest).		* Returns the AbstractTest instance that was passed in.		**/		public function queueTest(test:AbstractTest):AbstractTest {			return addToQueue(test) as AbstractTest;		}				/**		* Immediately runs the specified test.		* Returns the AbstractTest instance that was passed in. This is		* handy for immediately accessing the results of the test, like so:<br/>		* <code>trace(runTest(myTest));</code>		**/		public function runTest(test:AbstractTest):AbstractTest {			return runSynchronous(test) as AbstractTest;		}				/**		* Provides a shortcut for creating a TestSuite from the o parameter via TestSuite.fromObject()		* and adding it to the queue. Returns the TestSuite that was created, which		* is useful for adding listeners to it, and accessing the results when it		* is complete.		* <br/><br/>		* See <code>TestSuite.fromObject()</code> for information on the parameters.		**/		public function queueSimpleTestSuite(o:Object, name:String=null, iterations:uint=1):TestSuite {			return queueTestSuite( TestSuite.fromObject(o,name,iterations) );		}				/**		* Provides a shortcut for creating a TestSuite from the o parameter via TestSuite.fromObject()		* and running it immediately. Returns the TestSuite that was created, which is		* handy for accessing the results, such as:<br/>		* <code>trace(runSimpleTestSuite(testObj).time);</code>		* <br/><br/>		* See <code>TestSuite.fromObject()</code> for information on the parameters.		**/		public function runSimpleTestSuite(o:Object, name:String=null, iterations:uint=1):TestSuite {			return runTestSuite( TestSuite.fromObject(o,name,iterations) );		}				/**		* Provides a shortcut for creating a new Test instance and adding it to the queue.		* Returns the Test instance that was created,  which		* is useful for adding listeners to it, and accessing the results when it		* is complete.		* <br/><br/>		* See <code>Test</code> for information on the parameters.		**/		public function queueSimpleTest(f:Function, params:Array=null, name:String=null, iterations:uint=0, loops:uint=1):MethodTest {			return queueTest( new MethodTest(f,params,name,iterations,loops) ) as MethodTest;		}				/**		* Provides a shortcut for creating a new Test instance		* and running it immediately. Returns the Test instance that was created, which is		* handy for accessing the results, such as:<br/>		* <code>trace(runSimpleTest(myFunction).time);</code>		* <br/><br/>		* See <code>Test</code> for information on the parameters.		**/		public function runSimpleTest(f:Function, params:Array=null, name:String=null, iterations:uint=0, loops:uint=1):MethodTest {			return runTest( new MethodTest(f,params,name,iterations,loops) ) as MethodTest;		}			// protected methods:		/** @private **/		protected function addToQueue(o:EventDispatcher):EventDispatcher {			queue.push(o);			if (queue.length == 1) {				timer.reset();				timer.start();			}			return o;		}				/** @private **/		protected function runNext():void {			if (queue.length == 0) { return; }						if (queue[0] is TestSuite && queue[0] != _currentTestSuite) {				_currentTestSuite = queue[0];				index = -2;			}			if (_currentTestSuite) {				if (index == -2) {					if (_currentTestSuite.initFunction != null) { timeInitFunction(); }					else { index++; }				}				if (index == -1) {					if (_currentTestSuite.tareTest) { timeTareTest(); }					else { index++; }				}				if (index < 0) { index++; }				else if (index < _currentTestSuite.tests.length) {					if (timeTest(_currentTestSuite.tests[index])) { index++; }				}								if (index >= _currentTestSuite.tests.length) {					_currentTestSuite.complete();					_currentTestSuite = null;					queue.shift();				}			} else {				if (timeTest(queue[0] as AbstractTest)) { queue.shift(); }			}						if (queue.length == 0) { dispatchEvent(new Event(Event.CLOSE)); }			if (synchronous) { runNext(); }			else if (!_paused && queue.length > 0) {				timer.reset();				timer.start();			}		}				/** @private **/		protected function timeInitFunction():void {			var t:uint = getTimer();			_currentTestSuite.initFunction();			_currentTestSuite.initTime = getTimer()-t;		}				/** @private **/		protected function timeTareTest():void {			var tareTest:AbstractTest = _currentTestSuite.tareTest;			var i:int = tareTest.iterations == 0 ? 10 : tareTest.iterations;			var count:uint=0;			var good:Boolean=false;			var oldTime:int=-1;			while (!good && i-- > 0) {				count++;				var t:int = tareTest.run();				if (t < 0) { continue; }				var d:uint = Math.abs(t-oldTime);				good = (oldTime >= 0) && (d/(oldTime+t)*2 < 0.1 || d<2);				oldTime = t;			}			tareTest.iterations = count;			_currentTestSuite.tareTime = (t<0 || oldTime<0) ? -1 : (t+oldTime)/2;		}				/** @private **/		protected function timeTest(test:AbstractTest):Boolean {			if (_currentTest != test) {				iteration = 0;				_currentTest = test;				if (test.iterations == 0 && _currentTestSuite) {					test.iterations = _currentTestSuite.iterations;				}				if (test.iterations == 0) {					test.iterations = 1;				}			}			iteration++;						runGC();			var t:int = test.run();						var complete:Boolean = (t<0 || iteration >= _currentTest.iterations);			if (complete) {				_currentTest.complete();				dispatchEvent(new Event(Event.COMPLETE));				_currentTest = null;			}			return complete;		}				/** @private **/		protected function runSynchronous(o:EventDispatcher):EventDispatcher {			saveState();			_currentTest = null;			_currentTestSuite = null;			index = iteration = 0;			synchronous = true;			queue = [o];			runNext();			synchronous = false;			restoreState();			return o;		}				/** @private **/		protected function saveState():void {			savedState = {queue:queue,index:index,iteration:iteration,_currentTestSuite:_currentTestSuite,_currentTest:_currentTest,savedState:savedState};		}				/** @private **/		protected function restoreState():void {			var s:Object = savedState;			savedState = null;			for (var n:String in savedState) {				this[n] = s[n];			}		}			// event handlers:		/** @private **/		protected function handleTimer(evt:Event):void {			runNext();		}			}	}